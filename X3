#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define LINESIZE 100
#define TABLESIZE 1405
#define DATA 1405

struct tag_date
{
  int month;
  int day;
  int year;
} ;

typedef struct tag_date tag_date;

typedef struct tag_ocean
{
  tag_date date;
  float T_degC;
  float PO4uM;
  float SiO3uM;
  float NO2uM;
  float NO3uM;
  float Salnty;
  float O2ml_L;
} ocean;

void swap(ocean *ocean1, ocean *ocean2);
int compareDates(tag_date date1, tag_date date2);
void printValues(ocean values[]);
void equal(ocean *ocean1, ocean *ocean2);
int binarySearch(ocean arr[], int left, int right, ocean x);
int interpolationSearch(ocean arr[], int left, int right, ocean x);
void insertionSort(ocean values[], int n);
int makeDays(tag_date date);

int main()
{
  FILE *fp = fopen("ocean.csv", "r"); 
  if (!fp)
  {
    printf("fuck you");
    exit(0);
  }
  char buff[1024];
  ocean values[DATA]; // array

  int i = 0;
  char *field = (char *)malloc(sizeof(char) * LINESIZE);
  char *date_str = (char *)malloc(sizeof(char) * 10 + 1);
  fgets(field, LINESIZE-1, fp);
  while (fgets(field, LINESIZE - 1, fp) != NULL)
  {
    strcpy(date_str, strtok(field, ","));
    values[i].T_degC = atof(strtok(NULL, ","));
    values[i].PO4uM = atof(strtok(NULL, ","));
    values[i].SiO3uM = atof(strtok(NULL, ","));
    values[i].NO2uM = atof(strtok(NULL, ","));
    values[i].NO3uM = atof(strtok(NULL, ","));
    values[i].Salnty = atof(strtok(NULL, ","));
    values[i].O2ml_L = atof(strtok(NULL, ","));
    values[i].date.month = atoi(strtok(date_str, "/")); 
    values[i].date.day = atoi(strtok(NULL, "/"));      
    values[i].date.year = atoi(strtok(NULL, "/"));

    i++;
  }

  free(field);
  free(date_str);
  fclose(fp);
  ocean x;
  printf("Give month, day and year\n");
  scanf("%d%d%d", &x.date.month, &x.date.day, &x.date.year);
  int n;
  insertionSort(values, DATA);
  n = interpolationSearch(values, 1, DATA, x);       //BINARY OR INTERPOLATION
  printf("%d\n", n);

  if (n != -1)
  {
    int choice;
    printf("\n1.Temperature\n2.Phosphate\n3.Both\n(1, 2 or 3)\n");
    scanf("%d", &choice);
    if (choice == 1)
    {
      printf("%.2f", values[n].T_degC);
    }
    if (choice == 2)
    {
      printf("\nPhosphate = %.2f", values[n].PO4uM);
    }
    if (choice == 3)
    {
      printf("\nTemperature = %.2f\tPhosphate = %.2f", values[n].T_degC, values[n].PO4uM);
    }
  }
  else
  {
    printf("'date not found.\n");
  }
  return 0;
}

void printValues(ocean values[])
{
  int i = 1;
  printf("~~~~~~~~~~~~~~~~~~~~~~~~\n");

  for (i = 1; i < DATA; i++)
  {
    printf("%d\t%d\t%d\n", values[i].date.month, values[i].date.day, values[i].date.year);
  }
}

int compareDates(tag_date date1, tag_date date2) // date1-date2.
{
  if (date1.year > date2.year)
  {
    return 1;
  }
  else if (date1.year < date2.year)
  {
    return -1;
  }
  else if (date1.year == date2.year)
  {
    if (date1.month > date2.month)
    {
      return 1;
    }
    else if (date1.month < date2.month)
    {
      return -1;
    }
    else if (date1.month == date2.month)
    {
      if (date1.day > date2.day)
      {
        return 1;
      }
      else if (date1.day < date2.day)
      {
        return -1;
      }
      else
        return 0;
    }
  }
}


void insertionSort(ocean values[], int n)
{
  int i, j;
  ocean key;
  for (i=1; i<n; i++){
    equal(&key, &values[i]);
    j=i-1;
  
  while(j>=0 && compareDates(values[j].date, key.date)>0){
    equal(&values[j+1], &values[j]);
    j=j-1;
    
  }
  equal(&values[j+1], &key);
  }

}

void equal(ocean *ocean1, ocean *ocean2)
{
  ocean1->date.month = ocean2->date.month;
  ocean1->date.day = ocean2->date.day;
  ocean1->date.year = ocean2->date.year;
  ocean1->T_degC = ocean2->T_degC;
  ocean1->PO4uM = ocean2->PO4uM;
  ocean1->SiO3uM = ocean2->SiO3uM;
  ocean1->NO2uM = ocean2->NO2uM;
  ocean1->NO3uM = ocean2->NO3uM;
  ocean1->Salnty = ocean2->Salnty;
  ocean1->O2ml_L = ocean2->O2ml_L;
}



void swap(ocean *ocean1, ocean *ocean2)
{
    ocean temp;
    temp.date.month = ocean1->date.month;
    temp.date.day = ocean1->date.day;
    temp.date.year = ocean1->date.year;
    temp.T_degC = ocean1->T_degC;
    temp.PO4uM = ocean1->PO4uM;
    temp.SiO3uM = ocean1->SiO3uM;
    temp.NO2uM = ocean1->NO2uM;
    temp.NO3uM = ocean1->NO3uM;
    temp.Salnty = ocean1->Salnty;
    temp.O2ml_L = ocean1->O2ml_L;

    ocean1->date.month = ocean2->date.month;
    ocean1->date.day = ocean2->date.day;
    ocean1->date.year = ocean2->date.year;
    ocean1->T_degC = ocean2->T_degC;
    ocean1->PO4uM = ocean2->PO4uM;
    ocean1->SiO3uM = ocean2->SiO3uM;
    ocean1->NO2uM = ocean2->NO2uM;
    ocean1->NO3uM = ocean2->NO3uM;
    ocean1->Salnty = ocean2->Salnty;
    ocean1->O2ml_L = ocean2->O2ml_L;

    ocean2->date.month = temp.date.month;
    ocean2->date.day = temp.date.day;
    ocean2->date.year = temp.date.year;
    ocean2->T_degC = temp.T_degC;
    ocean2->PO4uM = temp.PO4uM;
    ocean2->SiO3uM = temp.SiO3uM;
    ocean2->NO2uM = temp.NO2uM;
    ocean2->NO3uM = temp.NO3uM;
    ocean2->Salnty = temp.Salnty;
    ocean2->O2ml_L = temp.O2ml_L;
}



int binarySearch(ocean arr[], int low, int high, ocean x)
{

  while (high >= low)
  {
    int mid = low + (high - low) / 2;
    if (compareDates(arr[mid].date, x.date) == 0)
    {
      return mid;
    }
    else if (compareDates(arr[mid].date, x.date) > 0)
    {
      high = mid - 1;
    }
    else if (compareDates(arr[mid].date, x.date) < 0)
    {
      low = mid + 1;
    }
  }

  return -1;
}

int interpolationSearch(ocean arr[], int low, int high, ocean x)
{
  int pos;
  pos=low + (high-low)*(makeDays(x.date)-makeDays(arr[low].date))/(makeDays(arr[high].date)-makeDays(arr[low].date));

    if (compareDates(arr[pos].date, x.date) == 0)
    {
      return pos;
    }

    if (compareDates(arr[pos].date, x.date) < 0)
    {
      return interpolationSearch(arr, pos + 1, high, x);
    }

    if (compareDates(arr[pos].date, x.date) > 0)
    {
      return interpolationSearch(arr, low, pos - 1, x);
    }
  

  return -1;
}


int makeDays(tag_date date){
  int days= (date.year-1)*12*30 + (date.month-1)*30 + date.day;
  return days;
}
